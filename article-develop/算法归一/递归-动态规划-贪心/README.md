## 递归
- 递归是一种解决问题的方法，它解决问题的各个小部分，直到解决最初的大问题
    - 通常涉及的就是函数自调用
```
// 能够像下面这样直接调用自身的方法or函数，就称为递归函数
let resFn = function(obj) {
    resFn(obj);
}
```
    - 每个递归函数都必须有一个边界条件(停止递归的条件)，以防止无序递归造成栈溢出错误(stack overflow error)
### 递归实现斐波那契数列
提到了递归，最典型的一个就是斐波那契数列了
还有不了解斐波那契数列的没关系，先来说一下它的定义：
1. 1和2的斐波那契数是1
2. n(n>2)的斐波那契数是(n-1)加上(n-2)的斐波那契数之和
实现它的代码也很简单
```
function fib(n) {
    if (n <= 2) return 1;
    return fib(n - 1) + fib(n - 2);
}
```
斐波那契函数就这样子写完了， 非常的easy，
下面还有一个很严重的问题没有解决，是什么呢？
那就是递归的最大问题，非常的占内存，很容易导致栈溢出错误
所以还是那句话，递归虽好，但不要贪杯哦！！！

接下来，我们就通过上面的fib函数可以算出40以内的斐波那契数是多少
别问我为什么说的是40，因为我在fib(50)的时候，亲测等了31.23秒后chrome提示该网页崩了无响应了（溢出了）
等了这么长的时间就出现了这种情况，怎么可以接受呢！

所以针对这一的情况，必须要有一个胶带啊，得给大家一个说法
于是乎出现了一个方法名词，它就是“尾递归优化”
### 尾递归优化实现斐波那契数列
```
function fib2(n, arg1 = 1, arg2 = 1) {
    if (n <= 2) return arg2;
    return fib2(n - 1, arg2, arg1 + arg2);
}

console.log(fib2(50));      // 12586269025
console.log(fib2(100));     // 354224848179262000000
console.log(fib2(1000));    // 4.346655768693743e+208
```
这种尾递归的好处就是，在ES6中只要使用尾递归，就不会发生栈溢出，相对节省了内存





## 动态规划
定义：动态规划被认为是一种与递归相反的技术
递归是从顶部开始分解出多个小问题，合并成一个解决方案
动态规划是从底部分解很多小问题解决掉，组成解决方案

- 在递归和动态规划的时候，我们往往会选择动态规划，因为它的效率非常高
- 而递归的时候每一次都要重新计算，这样会耗费非常大的内存


## 贪心算法
定义：它是一种寻找“优质解”为手段达成整体解决方案的算法
这些优质的解决方案为局部最优解
将有希望得到正确答案的最终解决方案称为全局最优解
贪心遵循一种近似解决问题的技术方案，期盼通过每个阶段的局部最优解，从而达到全局最优解
如果无法找到完整解决方案的问题，次优解也是可以接受的